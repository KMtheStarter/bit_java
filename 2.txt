JVM 메모리 구조
스택, 힙, 상수풀, 

인터페이스, 추상클래스, 상속을 사용하여 다형성을 구현.
추상클래스는 메뉴얼이라고 생각하면 됨.
추상메서드가 있는 클래스 > 추상클래스
추상메서드가 없는 클래스도 추상클래스가 될 수 있다.

자식클래스의 생성자에는 super()가 숨어져 있다. (부모의 생성자)

상속은 is a 관계. has a 관계와 다르다.
A가 부모, B가 자식이라고 할 때, 공통된 함수를 car()라고 하자.
B ref = new B로 해서 car()를 호출하면 B의 car()가 호출 됨.
A ref = new B로 해서 car()를 호출하면 A의 car()가 호출되고, 이는 B의 car()의 바로가기.
A ref = new A만 A의 car() 내용을 호출할 수 있음.
A의 car() 내용이 필요없다? car(); 로 선언해주면 A는 추상클래스.

추상클래스에 추상메서드가 5개 있다고 가정.
특정 클래스에서 추상클래스를 상속하고 1번 메소드만 사용하려고 한다.
하지만 나머지 4개의 메소드도 뜨게 됨.
이 때 1번 메소드만 사용하게 해주는 것이 adopter.
추상클래스 - 추상클래스 - 일반클래스

상속은 자식의 생성자에서 부모의 생성자를 호출해 주어야만 한다.
특수한 생성자를 사용할 경우, 자식도 동일한 생성자를 만들어 줘야 한다는 뜻 (super()).

기존에는 abstract, interface 메소드만 있었지만,
jdk 8 버전부터는 default, static 메소드 추가됨.

implements는 여러 개가 가능.
인터페이스간에는 다중 상속이 가능.
인터페이스를 상속해가며 표현하는 이유는 클래스간의 다형성을 보이기 위함.

has a 관계는 A 객체가 B 객체를 참조하는 관계이다.
결합도가 가장 높은 관계이기 때문에 변화에 민감한 관계.
객체간의 결합도를 낮추는 방법중 하나로 interface를 사용한 다형성을 활용하여
두 객체의 관계를 느슨하게 만들어준다.

클래스의 관계 4 + 1가지
- 연관 association: 생성자에서 다른 객체를 생성하는 관계. 참조가 유지되는 관계. (has a 관계)
- 집합 aggregation: 외부에서 생성자로 객체의 주소를 전달 받는 관계.
- 의존 dependency: 메서드에서 다른 객체를 생성하는 관계. 참조가 스택에 제한
- composition: 생성자 안에서 생성해서 참조하는 관계.
- 상속 inheritance

내부 클래스 - 재사용과 관련 없음.
1. 멤버 내부클래스
2. 로컬 내부클래스 - 이 안에서는 바로 위 스코프의 변수들을 상수로 취급하여 활용함
3. 스태틱 내부클래스
4. 익명 내부클래스 - 실행될때만 메모리에 잠깐 상주

어노테이션 - @로 시작하는 주석. 실행 가능한 주석.

람다는 오직 가독성을 위함.

자바의 오류와 예외처리
- 오류: 어쩔 수 없음. 시스템적인것.
- 일반적인 예외(컴파일 예외): 전구모양으로 뜨는 것. ex) 디모션
- 실행상태 예외(런타임 예외): integer로 파싱할 때 문자를 만난다던가.
요즘엔 finally 안쓰고 jdk7? 버전부터 제공되는 api인 오픈클로즈?를 사용.
throw는 예외를 발생시킬 때, throws는 예외를 위임할 때 사용.
예외의 최상위 클래스인 Exception 클래스를 상속받아 새로운 예외 정의 가능

split은 white space를 포함하여 나눔
stringtokenizer는 white space를 포함하지 않고 나눔

오토박싱 언박싱
Integer a = new Integer(10) 대신 Integer a = 10 해도 됨 > 오토박싱
int n = a 가 됨 > 언박싱